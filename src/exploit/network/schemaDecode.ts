import { Reflection, type Iterator, decode } from "@colyseus/schema";
import { Protocol } from "colyseus.js";
import { utf8Read, utf8Length } from "./protocol";
import { Buffer } from "buffer";
import { decode as msgpackdecode } from '@msgpack/msgpack';

class SchemaSerializer extends EventTarget {
    state: any;

    constructor() {
        super();
        this.state = null; // Explicitly initialize to null
    }

    setState(rawState: any) {
        if (!rawState || !this.state) {
          console.warn("Cannot set state: state is not initialized or rawState is invalid");
          return;
        }
        try {
          this.state.decode(rawState);
          this.dispatchEvent(new CustomEvent("patch", { detail: null }));
          this.dispatchEvent(new Event("load"));
        } catch (error) {
          console.error("Error decoding state:", error);
        }
    }

    getState() {
        return this.state;
    }

    // Some issue here
    /*
    join:17060 
     Uncaught TypeError: Cannot read properties of undefined (reading 'decode')
    at SchemaSerializer.patch (join:17060:34)
    at onMessage (join:17105:24)
    at NewWebSocket.<anonymous> (join:17185:31)
    */
    patch(patches: Buffer | number[]) {
        if (!this.state) {
          console.warn("Cannot apply patch: state is not initialized");
          return;
        }
        if (!patches || patches.length === 0) {
          console.warn("Invalid patches: empty or undefined");
          return;
        }
    
        try {
          const patchData = Array.isArray(patches) ? Buffer.from(patches) : patches;
          const changes = this.state.decode(patchData);
          if (Array.isArray(changes)) {
            for (const change of changes) {
              if (change.field !== "gameTime") {
                this.dispatchEvent(new CustomEvent("patch", { detail: changes }));
                break;
              }
            }
          }
        } catch (error) {
          console.error("Error applying patch:", error);
        }
    }

    teardown() {
        try {
          if (this.state?.["$changes"]?.root) {
            this.state["$changes"].root.clearRefs();
          }
        } catch (error) {
          console.error("Error during teardown:", error);
        }
    }

    handshake(bytes: number[], it?: { offset: number }) {
        try {
          if (this.state) {
            const reflection = new Reflection();
            reflection.decode(bytes, it);
          } else {
            // Initialize reflected state from server
            this.state = Reflection.decode(bytes, it) as any;
            if (!this.state || typeof this.state.decode !== "function") {
              throw new Error("Invalid state: decoded state lacks decode method");
            }
          }
          this.dispatchEvent(new CustomEvent("patch", { detail: null }));
        } catch (error) {
          console.error("Error during handshake:", error);
          this.state = null; // Reset state on error
        }
    }
}

export const serializer = new SchemaSerializer();

export function onMessage(event: MessageEvent) {
    const bytes = Array.from(new Uint8Array(event.data));
    const code = bytes[0];
    
    if (code === Protocol.JOIN_ROOM) {
        let offset = 1;

        const reconnectionToken = utf8Read(Buffer.from(bytes), offset);
        offset += utf8Length(reconnectionToken);
        
        const serializerId = utf8Read(Buffer.from(bytes), offset);
        offset += utf8Length(serializerId);

        console.log(reconnectionToken, serializerId, offset)

        if (bytes.length > offset) {
            serializer.handshake(bytes, { offset });
        }
    } else if (code === Protocol.ROOM_DATA_SCHEMA) {
        // don't think this matters
        // const it = { offset: 1 };

        // const context = (this.serializer.getState() as any).constructor._context;
        // const type = context.get(decode.number(bytes, it));

        // const message = new (type as any)();
        // message.decode(bytes, it);

        // this.dispatchMessage(type, message);
    } else if (code === Protocol.ROOM_STATE) {
        bytes.shift(); // drop `code` byte
        serializer.setState(bytes);
    } else if (code === Protocol.ROOM_STATE_PATCH) {
        bytes.shift(); // drop `code` byte
        serializer.patch(Buffer.from(bytes)); // Might not need Buffer.from
    } else if (code === Protocol.ROOM_DATA) {
        const it: decode.Iterator = { offset: 1 };

        const type = (decode.stringCheck(bytes, it))
            ? decode.string(bytes, it)
            : decode.number(bytes, it);
        
        //console.log("Event Data: ", event.data)
        const data = Buffer.from(bytes);
        //console.log("Data: ", data)
        //console.log("Subarray: ", data.subarray(it.offset))
        //console.log("Decoded: ", msgpackdecode(data.subarray(it.offset)))
        const message = (bytes.length > it.offset)
            ? msgpackdecode(data.subarray(it.offset)) // Might not need Buffer.from
            : undefined;

        return { type, message }
    } else if (code === Protocol.ROOM_DATA_BYTES) {
        const it: decode.Iterator = { offset: 1 };

        const type = (decode.stringCheck(bytes, it))
            ? decode.string(bytes, it)
            : decode.number(bytes, it);

        return { type, message: new Uint8Array(bytes.slice(it.offset)) }
    }

    return null;
}