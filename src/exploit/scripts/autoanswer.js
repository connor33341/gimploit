import socketManager from "../network/socketManager";
import { playerId } from "../stores";
import config from "../config/autoanswer.json"

let { transportType } = socketManager;

let questions = []
let answerDeviceId = null;
let currentQuestionId = null;
let questionIdList = [];
let currentQuestionIndex = -1;
let rIntervalMin = config.interval.min;
let rIntervalMax = config.interval.max;

function answerQuestion() {
    console.log(`Auto answering question, using transport type ${transportType}`);
    if (transportType === 'colyseus') {
        console.log(`Auto answering question, using colyseus transport type: ${currentQuestionId}`);
        if (currentQuestionId == null) return;

        // find the correct question
        let question = questions.find(q => q._id == currentQuestionId);
        if (!question) return;

        let packet = {
            key: 'answered',
            deviceId: answerDeviceId,
            data: {}
        }

        // create a packet to send to the server
        if (question.type == 'text') {
            packet.data.answer = question.answers[0].text;
        } else {
            let correctAnswerId = question.answers.find((a) => a.correct)._id
            packet.data.answer = correctAnswerId
        }

        socketManager.sendMessage("MESSAGE_FOR_DEVICE", packet);
    } else {
        let questionId = questionIdList[currentQuestionIndex]

        let question = questions.find(q => q._id == questionId)
        if (!question) return;

        let answer;
        if (question.type == 'mc') {
            answer = question.answers.find((a) => a.correct)._id
        } else {
            answer = question.answers[0].text
        }

        socketManager.sendMessage("QUESTION_ANSWERED", {
            answer,
            questionId: questionId
        })
    }
}

let answerInterval; // should probably be a number but I don't care
let lastState = false
export function toggleAutoAnswer() {
    console.log(`Auto Answer: ${lastState ? "OFF" : "ON"}`);
    if (!lastState) {
        lastState = !lastState;
        let rInterval = Math.floor(Math.random() * (rIntervalMax - rIntervalMin + 1)) + rIntervalMin;
        answerInterval = setInterval(answerQuestion, rInterval);
    } else {
        lastState = !lastState;
        clearInterval(answerInterval);
    }
}

export function setup(){
    socketManager.addEventListener("deviceChanges", (event) => {
        for (let { id, data } of event.detail) {
            for (let key in data) {
                if (key == "GLOBAL_questions") {
                    questions = JSON.parse(data[key]);
                    console.log("Got questions", questions);
                    answerDeviceId = id;
                }
    
                if (key == `PLAYER_${playerId}_currentQuestionId`) {
                    currentQuestionId = data[key];
                }
            }
        }
    });
    socketManager.addEventListener("blueboatMessage", (event) => {
        if (event.detail?.key != "STATE_UPDATE") return;
    
        switch (event.detail.data.type) {
            case "GAME_QUESTIONS":
                questions = event.detail.data.value;
                break;
    
            case "PLAYER_QUESTION_LIST":
                questionIdList = event.detail.data.value.questionList;
                currentQuestionIndex = event.detail.data.value.questionIndex;
                break;
    
            case "PLAYER_QUESTION_LIST_INDEX":
                currentQuestionIndex = event.detail.data.value;
                break;
        }
    });
}
